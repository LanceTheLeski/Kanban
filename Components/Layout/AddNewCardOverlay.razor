@using Newtonsoft.Json
@using Kanban.Components.DTOs
@using Kanban.Components.DTOs.ToPossiblyDelete
@using Kanban.Components.Layout
@using System.Net.Http.Headers

@inject HttpClient http
@inject NavigationManager NavigationManager

@inherits LayoutComponentBase

<MudOverlay @bind-Visible="Open" DarkBackground="true" ZIndex="10"><!--Add card-->
    <MudPaper Width="600px">
        <MudText>Add a New Card</MudText>
        <MudTextField T="string" Label="Title" Variant="Variant.Filled" HelperText="Card Title" />
        <MudTextField T="string" Label="Description" Variant="Variant.Filled" AutoGrow Lines="7" HelperText="Description" />
         <MudExpansionPanels>
             <MudExpansionPanel Text="Column" MaxHeight="1000" IsExpandedChanged="ExpandedChanged">
                 @_panelContent
            </MudExpansionPanel>
        </MudExpansionPanels>
        <!--
        <MudSelect T="string" Label="Swimlane" Variant="Variant.Filled" AnchorOrigin="Origin.TopCenter" @bind-Value="swimlaneToAddCard">
            @foreach (var swimlaneTitle in _swimlaneTitles)
            {
                <MudSelectItem Style="width: 100px; height: 200px;" T="string" Value="@swimlaneTitle" />
            }
        </MudSelect>
        -->
        <MudButtonGroup>
            <MudButton OnClick="(() => CreateCard())">Submit</MudButton>
            <MudButton OnClick="CloseCardOverlay">Discard</MudButton>
        </MudButtonGroup>
    </MudPaper>
</MudOverlay>
@code
{
    [Parameter]
    public bool Open { get; set; }
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    [Parameter]
    public List<DropCard>? Cards { get; set; }
    [Parameter]
    public EventCallback<List<DropCard>> CardsChanged { get; set; }

    [Parameter]
    public List<Guid>? Columns { get; set; }
    [Parameter]
    public EventCallback<List<Guid>> ColumnsChanged { get; set; }

    [Parameter]
    public List<string> ColumnTitles { get; set; }
    [Parameter]
    public EventCallback<List<string>> ColumnTitlesChanged { get; set; }

    [Parameter]
    public List<Guid> Swimlanes { get; set; }
    public EventCallback<List<string>> SwimlanesChanged { get; set; }

    [Parameter]
    public List<string> SwimlaneTitles { get; set; }
    public EventCallback<List<string>> SwimlaneTitlesChanged { get; set; }

    //private List<DropCard> _cards = new List<DropCard>();
    //private List<Guid> _columns = new List<Guid>();
    private static List<string> _columnTitles = new List<string>();
    //private List<Guid> _swimlanes = new List<Guid>();
    //private List<string> _swimlaneTitles = new List<string>();

    //On page load. Not async.
    protected override void OnInitialized ()
    {
        //_cards = Cards.Value;
        _columnTitles = ColumnTitles;
    }


    private RenderFragment _panelContent;
    private async Task ExpandedChanged (bool newVal)
    {
        if (newVal)
        {
            _panelContent = _bigAsyncContent;
        }
        else
        {
            // Reset after a while to prevent sudden collapse.
            Task.Delay (350).ContinueWith (t => _panelContent = null).AndForget ();
        }
    }

    private RenderFragment _bigAsyncContent = __builder =>
    {
        <MudPaper Class="d-inline-flex flex-grow-1 overflow-auto" Style="width: 300px; height: 200px;">
            <MudStack Class="flex-grow-1" Width="100%" Height="100%">
                @foreach (var columnTitle in _columnTitles)
                {
                    <MudListItem>
                        Column Name: @(columnTitle)
                    </MudListItem>
                }
            </MudStack>
        </MudPaper>
    };

    public string cardTitle = "";
    public string cardDescription = "";
    public string columnToAddCard = "";
    public string swimlaneToAddCard = "";
    public async Task<CardResponse> CreateCard () //We will probably want a restriction down the road that swimlanes and columns don't have duplicate titles
    {
        var createRequest = new CardCreateRequest
            {
                Title = cardTitle,
                Description = cardDescription,
                BoardID = Guid.Parse ("20a88077-10d4-4648-92cb-7dc7ba5b8df5"),
                ColumnID = Columns [ColumnTitles.IndexOf (columnToAddCard)],
                SwimlaneID = Swimlanes [SwimlaneTitles.IndexOf (swimlaneToAddCard)]
            };

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Post, @$"{NavigationManager.BaseUri}kanban/cards/createcard");
        httpRequestMessage.Content = new StringContent (JsonConvert.SerializeObject (createRequest), mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<CardResponse> (responseBody);

            //Add it to the DropCard list? And if we want to use the boardResponse as a source of truth then that too? But I don't think that should be the case
            Cards.Add (new DropCard
                {
                    Id = deserialized.ID,
                    Title = deserialized.Title,
                    Description = deserialized.Description,
                    ColumnNumber = deserialized.ColumnOrder,
                    ColumnID = Guid.Parse (deserialized.ColumnID),
                    ColumnName = deserialized.ColumnTitle,
                    SwimlaneNumber = deserialized.SwimlaneOrder,
                    SwimlaneID = Guid.Parse (deserialized.SwimlaneID),
                    SwimlaneName = deserialized.SwimlaneTitle,
                    CardArea = ConvertColumnAndSwimlaneToCardArea (deserialized.SwimlaneOrder, deserialized.ColumnOrder)
                });

            return deserialized;
        }

        return null;
    }

    private string ConvertColumnAndSwimlaneToCardArea (int swimlanePos, int columnPos)
    {
        return (swimlanePos + "_" + columnPos);
    }

    private void CloseCardOverlay ()
    {
        Open = false;
    }
}