@using Newtonsoft.Json
@using Kanban.Components.DTOs
@using Kanban.Components.DTOs.ToPossiblyDelete
@using System.Net.Http.Headers

@inject HttpClient http
@inject NavigationManager NavigationManager

@rendermode RenderMode.InteractiveServer

<MudPaper>
    <MudButton OnClick="OpenCardOverlay">Add Card</MudButton><!--Should be added to each CardArea instead so the card goes there immediately-->
    <MudButton OnClick="OpenSwimlaneOverlay">Add/Edit Swimlane</MudButton>
    <MudButton OnClick="OpenColumnOverlay">Add/Edit Column</MudButton>
    <MudButton OnClick="OpenBoardOverlay">Edit Board</MudButton>
    <MudButton OnClick="Troubleshoot">Custom Text: @TroubleshootText</MudButton>
</MudPaper>
<MudGrid Class="d-flex flex-column" Style="background-color: lightblue" Spacing="0">
    <MudItem>
        <MudPaper Height="75px" Style="background-color: yellowgreen">
            <MudGrid>
                <MudItem>
                    <MudPaper Width="120px">X</MudPaper>
                </MudItem>
                @foreach (var columnIndex in Enumerable.Range (0, _columnTitles.Count ()))
                {
                    <MudItem>
                        <MudPaper Width="150px" Style="background-color: darkturquoise" Class="align-self-center">@(_columnTitles [columnIndex])</MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudPaper>
    </MudItem>
    <MudDropContainer T="DropCard" Items="_cards" ItemDropped="ItemUpdated" ItemsSelector="@((card, dropzone) => card.CardArea == dropzone)">
        <ChildContent>
            <!--Can convert the below loop and rowList loop to Range of numbers like above... That would probable be better ? -->
            @foreach (var rowIndex in Enumerable.Range(0, _swimlaneTitles.Count()))
            {
                <MudItem>
                    <MudPaper Height="250px" Style="background-color: wheat">
                        <MudGrid>
                            <MudItem>
                                <MudPaper Width="120px" Style="background-color: lightcoral" Class="align-self-center">@(_swimlaneTitles [rowIndex])</MudPaper>
                            </MudItem>

                            @foreach (var columnIndex in Enumerable.Range (0, _columnTitles.Count ()))
                            {
                                var identifier = rowIndex + "_" + columnIndex;
                                <MudItem Style="height: 250px;">
                                    <MudList Clickable="true" Class="d-flex flex-column mud-height-full" Style="height: 250px;">
                                    <!--We want columns to have a set width-->
                                    <!--This paper is important and will hold all fot he cards. There will have to be ways of expanding and moving cards between theses.-->
                                        <MudDropZone CanDrop="@((dropcard) => true)" T="DropCard" Identifier="@identifier" CanDropClass="mud-border-success" Style="background-color: cornflowerblue; width: 150px; height: 200px;" Class="d-flex flex-wrap flex-grow-1 justify-space-around gap-4 pa-2 overflow-auto" />
                                    </MudList>
                                </MudItem>
                            }
                        </MudGrid>
                    </MudPaper>
                </MudItem>
            }
        </ChildContent>
        <ItemRenderer>
            <MudPaper Class="rounded-lg gap-0" Style="width: 100px; height: 200px; text-align: center; background-color: lightyellow">
                <MudStack Class="d-inline-flex flex-grow-1" AlignItems="AlignItems.Center" Spacing="0">
                    <MudPaper Width="100%" MinHeight="160px;">
                        <MudListItem OnClick="(() => OpenOverlay(context))">
                            
                                <MudText Align="Align.Center">@context.Title</MudText>
                                <br />
                                <MudText Style="max-height: 70px;">@context.Description</MudText>
                            
                        </MudListItem>
                    </MudPaper>
                    <MudPaper Width="100%">
                        <MudButton Size="Size.Small">Edit</MudButton>
                    </MudPaper>
                </MudStack>
            </MudPaper>
        </ItemRenderer>

    </MudDropContainer>
</MudGrid>

<MudOverlay @bind-Visible="overlayIsVisible" DarkBackground="true" ZIndex="100" AutoClose="true"><!--Edit card-->
    <MudPaper>
        @cardSelected.Title
    </MudPaper>
</MudOverlay>

<MudOverlay @bind-Visible="cardOverlayIsVisible" DarkBackground="true" ZIndex="10"><!--Add card-->
    <MudPaper Width="600px">
        <MudText>Add a New Card</MudText>
        <MudTextField T="string" Label="Title" Variant="Variant.Filled" HelperText="Card Title" />
        <MudTextField T="string" Label="Description" Variant="Variant.Filled" AutoGrow Lines="7" HelperText="Description" />
        <MudExpansionPanels>
             <MudExpansionPanel Text="Column" MaxHeight="1000" IsExpandedChanged="ExpandedChanged">
                @_panelContent
            </MudExpansionPanel>
        </MudExpansionPanels>
        <!--<MudSelect T="string" Label="Column" Variant="Variant.Filled" AnchorOrigin="Origin.TopCenter" @bind-Value="columnToAddCard">
            @foreach (var columnIndex in Enumerable.Range(0, _columnTitles.Count()))//THIS IS NOT UPDATING AFTER 
            {
                <MudSelectItem T="string" Value="@(_columnTitles [columnIndex])">
                    @(_columnTitles [columnIndex])
                </MudSelectItem>
            }
        </MudSelect>-->
        <MudSelect T="string" Label="Swimlane" Variant="Variant.Filled" AnchorOrigin="Origin.TopCenter" @bind-Value="swimlaneToAddCard">
            @foreach (var swimlaneTitle in _swimlaneTitles)
            {
                <MudSelectItem Style="width: 100px; height: 200px;" T="string" Value="@swimlaneTitle"/>
            }
        </MudSelect>
        <MudButtonGroup>
            <MudButton OnClick="(() => CreateCard())">Submit</MudButton>
            <MudButton OnClick="CloseCardOverlay">Discard</MudButton>
        </MudButtonGroup>
    </MudPaper>
</MudOverlay>

<MudOverlay @bind-Visible="swimlaneOverlayIsVisible" DarkBackground="true" ZIndex="100"><!--Add Swimlane-->
    <MudPaper>
        <MudText>Add a New Swimlane</MudText>
        <MudTextField T="string" Label="Title" Variant="Variant.Filled" AutoGrow HelperText="Swimlane Title" />
        <MudButtonGroup>
            <MudButton>Submit</MudButton>
            <MudButton OnClick="CloseSwimlaneOverlay">Discard</MudButton>
        </MudButtonGroup>
    </MudPaper>
</MudOverlay>

<MudOverlay @bind-Visible="columnOverlayIsVisible" DarkBackground="true" ZIndex="100"><!--Add Column-->
     <MudPaper>
        <MudText>Add a New Column</MudText>
        <MudTextField T="string" @bind-Value="columnTitle" Label="Title" Variant="Variant.Filled" AutoGrow HelperText="Column Title" />
        <MudTextField T="string" @bind-Value="columnOrder" Label="Order" Variant="Variant.Filled" AutoGrow HelperText="Column Order" />
        <MudButtonGroup>
            <MudButton OnClick="(() => CreateColumn())">Submit</MudButton>
            <MudButton OnClick="CloseColumnOverlay">Discard</MudButton>
        </MudButtonGroup>
     </MudPaper>
</MudOverlay>

<MudOverlay @bind-Visible="boardOverlayIsVisible" DarkBackground="true" ZIndex="100"><!--Board Menu-->
     <MudPaper>
        <MudText>Add/Edit Board</MudText>
        <MudTextField T="string" Label="Title" Variant="Variant.Filled" AutoGrow HelperText="Board Title" />
        <MudButtonGroup>
            <MudButton>Submit</MudButton>
            <MudButton OnClick="CloseBoardOverlay">Discard</MudButton>
        </MudButtonGroup>
     </MudPaper>
</MudOverlay>

<MudOverlay @bind-Visible="calendarOverlayIsVisible" DarkBackground="true" ZIndex="100"><!--Calendar Screen-->
     <MudPaper>
         <MudText>Edit calendar</MudText>
         <MudButtonGroup>
             <MudButton>Submit</MudButton>
             <MudButton OnClick="CloseCalendarOverlay">Discard</MudButton>
         </MudButtonGroup>
     </MudPaper>
</MudOverlay>

@code
 {
    //On page load:
    protected override async Task OnInitializedAsync ()
    {
        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Get, @$"{NavigationManager.BaseUri}kanban/getboard/20a88077-10d4-4648-92cb-7dc7ba5b8df5");

        var response = await http.SendAsync (httpRequestMessage);
        var responseBody = await response.Content.ReadAsStringAsync ();
        if (response.IsSuccessStatusCode)
        {
            var deserialized = JsonConvert.DeserializeObject<BoardResponse> (responseBody);

            TroubleshootText = deserialized.Columns.FirstOrDefault()?.Title; //Works!!

            _cards = ConvertBoardResponseToDropCardList (deserialized);
        }
    }

    public string TroubleshootText = "...Loading...";

    public void Troubleshoot ()
    {

    }

    private RenderFragment _panelContent;

    private async Task ExpandedChanged (bool newVal)
    {
        if (newVal)
        {
            _panelContent = _bigAsyncContent;
        }
        else
        {
            // Reset after a while to prevent sudden collapse.
            Task.Delay (350).ContinueWith (t => _panelContent = null).AndForget ();
        }
    }

    public static Guid? ColumnForCreateCard = null;
    private RenderFragment _bigAsyncContent = __builder =>
    {
        <MudPaper Class="d-inline-flex flex-grow-1 overflow-auto" Style="width: 300px; height: 200px;">
            <MudStack Class="flex-grow-1" Width="100%" Height="100%">
                @foreach (var columnTitle in _columnTitles)
                {
                    <MudListItem>
                        Column Name: @(columnTitle)
                    </MudListItem>
                } 
            </MudStack>
        </MudPaper>
    };
    public static void SetColumnForCreateCard(string columnTitle)
    {
        ColumnForCreateCard = _columns[_columnTitles.IndexOf(columnTitle)];
    }

    public Card cardSelected = null;

    private void EditCard (Card cardToEdit)
    {

    }
    private void EditSwimlane (Swimlane swimlane)
    {

    }
    public void EditColumn (Column column)
    {

    }
    public void EditBoard (Board board)
    {

    }

    private void ItemUpdated (MudItemDropInfo<DropCard> cardToUpdate)
    {
        cardToUpdate.Item.CardArea = cardToUpdate.DropzoneIdentifier;

        var newCardArea = ConvertCardAreaToColumnAndSwimlane (cardToUpdate.Item.CardArea);
        cardToUpdate.Item.ColumnID = _columns [newCardArea.columnPos];
        cardToUpdate.Item.ColumnName = _columnTitles [newCardArea.columnPos];
        cardToUpdate.Item.ColumnNumber = newCardArea.columnPos;
        cardToUpdate.Item.SwimlaneID = _swimlanes [newCardArea.swimlanePos];
        cardToUpdate.Item.SwimlaneName = _swimlaneTitles [newCardArea.swimlanePos];
        cardToUpdate.Item.SwimlaneNumber = newCardArea.swimlanePos;

        var cardResponse = Task.Run(() => 
            SendPatchRequest (cardToUpdate.Item)).Result;
    }
    private async Task<CardResponse?> SendPatchRequest (DropCard cardToUpdate)
    {
        var patchRequest = $@"[
            {{ ""op"": ""replace"", ""path"": ""/ColumnID"", ""value"": ""{cardToUpdate.ColumnID}"" }}, 
            {{ ""op"": ""replace"", ""path"": ""/ColumnTitle"", ""value"": ""{cardToUpdate.ColumnName}"" }},
            {{ ""op"": ""replace"", ""path"": ""/ColumnOrder"", ""value"": ""{cardToUpdate.ColumnNumber}"" }},
            {{ ""op"": ""replace"", ""path"": ""/SwimlaneID"", ""value"": ""{cardToUpdate.SwimlaneID}"" }},
            {{ ""op"": ""replace"", ""path"": ""/SwimlaneTitle"", ""value"": ""{cardToUpdate.SwimlaneName}"" }},
            {{ ""op"": ""replace"", ""path"": ""/SwimlaneOrder"", ""value"": ""{cardToUpdate.SwimlaneNumber}"" }}
        ]";

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Patch, @$"{NavigationManager.BaseUri}kanban/cards/updatecard/{cardToUpdate.Id}");
        httpRequestMessage.Content = new StringContent (patchRequest, mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<CardResponse> (responseBody);

            //tempString = deserialized.Columns.FirstOrDefault ()?.Title; //Works!!

            return deserialized;
        }

        return null;
    }

    public class DropCard : Card
    {
        public string CardArea { get; set; }
    }

    public bool overlayIsVisible = false;
    public void OpenOverlay(Card cardToOverlay)
    {
        cardSelected = cardToOverlay;
        overlayIsVisible = true;
    }

    public bool cardOverlayIsVisible = false;
    public string cardTitle = "";
    public string cardDescription = "";
    public string columnToAddCard = "";
    public string swimlaneToAddCard = "";
    public void OpenCardOverlay ()
    {
        cardOverlayIsVisible = true;
        StateHasChanged();
    }
    public void CloseCardOverlay ()
    {
        cardOverlayIsVisible = false;
    }
    public async Task<CardResponse> CreateCard () //We will probably want a restriction down the road that swimlanes and columns don't have duplicate titles
    {
        var createRequest = new CardCreateRequest
        {
            Title = cardTitle,
            Description = cardDescription,
            BoardID = Guid.Parse ("20a88077-10d4-4648-92cb-7dc7ba5b8df5"),
            ColumnID = _columns [_columnTitles.IndexOf (columnToAddCard)],
            SwimlaneID = _swimlanes [_swimlaneTitles.IndexOf (swimlaneToAddCard)]
        };

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Post, @$"{NavigationManager.BaseUri}kanban/cards/createcard");
        httpRequestMessage.Content = new StringContent (JsonConvert.SerializeObject (createRequest), mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<CardResponse> (responseBody);

            //Add it to the DropCard list? And if we want to use the boardResponse as a source of truth then that too? But I don't think that should be the case
            _cards.Add(new DropCard
            { 
                Id = deserialized.ID,
                Title = deserialized.Title,
                Description = deserialized.Description,
                ColumnNumber = deserialized.ColumnOrder,
                ColumnID = Guid.Parse (deserialized.ColumnID),
                ColumnName = deserialized.ColumnTitle,
                SwimlaneNumber = deserialized.SwimlaneOrder,
                SwimlaneID = Guid.Parse (deserialized.SwimlaneID),
                SwimlaneName = deserialized.SwimlaneTitle,
                CardArea = ConvertColumnAndSwimlaneToCardArea (deserialized.SwimlaneOrder, deserialized.ColumnOrder)
            });

            return deserialized;
        }

        return null;
    }

    public bool swimlaneOverlayIsVisible = false;
    private string swimlaneTitle = "";
    private string swimlaneOrder = "";
    public void OpenSwimlaneOverlay ()
    {
        swimlaneOverlayIsVisible = true;
    }
    public void CloseSwimlaneOverlay ()
    {
        swimlaneOverlayIsVisible = false;
    }
    public async Task<SwimlaneResponse> CreateSwimlane ()
    {
        var createRequest = new SwimlaneCreateRequest
        {
            Title = swimlaneTitle,
            Order = int.Parse (swimlaneOrder),
            BoardID = Guid.Parse ("20a88077-10d4-4648-92cb-7dc7ba5b8df5")
        };

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Patch, @$"{NavigationManager.BaseUri}kanban/updateswimlane");
        httpRequestMessage.Content = new StringContent (JsonConvert.SerializeObject (createRequest), mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<SwimlaneResponse> (responseBody);

            _swimlanes.Insert (deserialized.Order, deserialized.ID);
            _swimlaneTitles.Insert (deserialized.Order, deserialized.Title);

            //Cards will need to have their position (SwimlaneOrder) changed as well

            return deserialized;
        }

        return null;
    }
    public async Task<SwimlaneResponse> EditSwimlane (string swimlaneTitle, int swimlaneOrder) //Parameters should not be null. Defaults should be set in the UI probably
    {
        var patchRequest = $@"[
            {{ ""op"": ""replace"", ""path"": ""/Title"", ""value"": ""{swimlaneTitle}"" }},
            {{ ""op"": ""replace"", ""path"": ""/Order"", ""value"": ""{swimlaneOrder}"" }}
        ]";

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Post, @$"{NavigationManager.BaseUri}kanban/createswimlane");
        httpRequestMessage.Content = new StringContent (JsonConvert.SerializeObject (patchRequest), mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<SwimlaneResponse> (responseBody);

            _swimlanes [deserialized.Order] = deserialized.ID;
            _swimlaneTitles [deserialized.Order] = deserialized.Title;

            //Cards will need to have their position (SwimlaneOrder) changed as well

            return deserialized;
        }

        return null;
    }

    public bool columnOverlayIsVisible = false;
    private string columnTitle = "";
    private string columnOrder = "";
    public void OpenColumnOverlay ()
    {
        columnOverlayIsVisible = true;
    }
    public void CloseColumnOverlay ()
    {
        columnOverlayIsVisible = false;
    }
    public async Task<ColumnResponse> CreateColumn ()
    {
        var createRequest = new ColumnCreateRequest
        {
            Title = columnTitle,
            Order = int.Parse(columnOrder),
            BoardID = Guid.Parse("20a88077-10d4-4648-92cb-7dc7ba5b8df5")
        };

        var httpRequestMessage = new HttpRequestMessage (HttpMethod.Post, @$"{NavigationManager.BaseUri}kanban/createcolumn");
        httpRequestMessage.Content = new StringContent (JsonConvert.SerializeObject(createRequest), mediaType: new MediaTypeHeaderValue (@"application/json"));

        var response = await http.SendAsync (httpRequestMessage);
        if (response.IsSuccessStatusCode)
        {
            var responseBody = await response.Content.ReadAsStringAsync ();
            var deserialized = JsonConvert.DeserializeObject<ColumnResponse> (responseBody);

            _columns.Insert (deserialized.Order, deserialized.ID);
            _columnTitles.Insert (deserialized.Order, deserialized.Title);

            return deserialized;
        }

        return null;
    }

    public bool boardOverlayIsVisible = false;
    public void OpenBoardOverlay ()
    {
        boardOverlayIsVisible = true;
    }
    public void CloseBoardOverlay ()
    {
        boardOverlayIsVisible = false;
    }

    public bool calendarOverlayIsVisible = false;
    public void OpenCalendarOverlay ()
    {
        calendarOverlayIsVisible = true;
    }
    public void CloseCalendarOverlay ()
    {
        calendarOverlayIsVisible = false;
    }

    private (int swimlanePos, int columnPos) ConvertCardAreaToColumnAndSwimlane(string cardAreaValue)
    {
        var swimlanePos_columnPos = cardAreaValue.Split ("_");
        var swimlanePos = int.Parse (swimlanePos_columnPos.First ());
        var columnPos = int.Parse (swimlanePos_columnPos.Last ());

        return (swimlanePos, columnPos);
    }

    private string ConvertColumnAndSwimlaneToCardArea (int swimlanePos, int columnPos)
    {
        return (swimlanePos + "_" + columnPos);
    }

    private List<DropCard> ConvertBoardResponseToDropCardList (BoardResponse boardResponse)
    {
        var dropCardList = new List<DropCard>();

        _columnTitles = new List<string> ();
        _columns = new List<Guid> ();
        _swimlaneTitles = new List<string> ();
        _swimlanes = new List<Guid> ();

        var columnList = boardResponse.Columns;
        for (int columnIndex = 0; columnIndex < columnList.Count; columnIndex ++)
        {
            var swimlaneList = columnList [columnIndex].Swimlanes;

            for (int swimlaneIndex = 0; swimlaneIndex < swimlaneList.Count; swimlaneIndex ++)
            {
                var cardList = swimlaneList [swimlaneIndex].Cards;

                var cardArea = ConvertColumnAndSwimlaneToCardArea(swimlaneList [swimlaneIndex].Order, columnList [columnIndex].Order);
                foreach (var card in cardList)
                {
                    dropCardList.Add(new DropCard
                    {
                        Id = card.ID,
                        Title = card.Title,
                        Description = card.Description,
                        ColumnNumber = columnIndex,
                        ColumnID = Guid.Parse(columnList [columnIndex].ID),
                        ColumnName = columnList [columnIndex].Title,
                        SwimlaneNumber = swimlaneIndex,
                        SwimlaneID = Guid.Parse(swimlaneList [swimlaneIndex].ID),
                        SwimlaneName = swimlaneList [swimlaneIndex].Title,
                        CardArea = cardArea
                    });
                }
            }

            _columnTitles.Add (columnList [columnIndex].Title);
            _columns.Add (Guid.Parse(columnList [columnIndex].ID));
        }

        for (int swimlaneIndex = 0; swimlaneIndex < columnList [0].Swimlanes.Count; swimlaneIndex ++)
        {
            _swimlaneTitles.Add (columnList [0].Swimlanes [swimlaneIndex].Title);
            _swimlanes.Add(Guid.Parse(columnList[0].Swimlanes[swimlaneIndex].ID));
        }

        return dropCardList;
    }

    public List<DropCard> _cards = new List<DropCard>();

    public static List<string> _swimlaneTitles = new ();
    public static List<Guid> _swimlanes = new List<Guid> ();

    public static List<string> _columnTitles = new ();
    public static List<Guid> _columns = new List<Guid> ();
}